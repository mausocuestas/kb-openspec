# Design: Feedback Storage Implementation

## Context
The feedback component currently provides a UI for users to rate documents (thumbs up/down) and leave comments, but submissions are only simulated. We need to capture this valuable data for healthcare professionals to improve document quality based on real user feedback.

## Goals / Non-Goals
- Goals:
  - Store user feedback with proper validation and error handling
  - Enable data analysis for document quality improvement
  - Provide reliable feedback submission with good UX
  - Implement rate limiting to prevent spam
- Non-Goals:
  - User authentication/authorization (anonymous feedback allowed)
  - Real-time feedback analytics dashboard
  - Email notifications for feedback submission

## Decisions
- Database: Neon PostgreSQL (already accessible per requirements)
- Validation: Server-side validation with proper sanitization
- Rate Limiting: Simple IP-based limiting to prevent spam
- Schema: Simple normalized table with essential fields
- Error Handling: Graceful degradation with user-friendly messages

### Technical Architecture
```
Frontend (Feedback.astro)
    → POST /api/feedback (Astro API Route)
    → Validation & Rate Limiting
    → Neon PostgreSQL INSERT
    → Response (success/error)
```

## Database Schema Design
**Connection:** `postgresql://neondb_owner:...` (via DATABASE_URL env var)
**Schema:** `kb` schema

```sql
-- Create in kb schema
CREATE TABLE kb.feedback (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    rating VARCHAR(10) NOT NULL CHECK (rating IN ('positive', 'negative')),
    comment TEXT,
    page_url VARCHAR(500) NOT NULL,
    page_title VARCHAR(200) NOT NULL,
    user_agent TEXT,
    ip_address VARCHAR(45), -- IPv4: 15 chars, IPv6: 45 chars max
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX idx_feedback_created_at ON kb.feedback (created_at);
CREATE INDEX idx_feedback_page_url ON kb.feedback (page_url);
```

## Risks / Trade-offs
- Spam risk → Mitigated with rate limiting and validation
- PII exposure → Minimal data collection, no personal identifiers
- Performance impact → Lightweight table with proper indexing
- Database costs → Low volume expected, Neon free tier sufficient

## Migration Plan
1. Create database table in Neon
2. Add environment variables for DB connection
3. Implement API endpoint with validation
4. Update frontend component to call API
5. Test end-to-end flow
6. Monitor for issues

## Open Questions
- What rate limit threshold is appropriate? (e.g., 5 submissions per hour per IP)
- Should we store user agent string for analytics?
- Do we need any additional metadata fields?